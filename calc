#!node --experimental-default-type=module
import fs from 'fs';
const { stdin, stdout } = process,
extrarows = stdin.isTTY && process.argv.length === 2 ? 2 : 0;
const w = m => stdout.write(m+'');
Array.prototype.find_and_map = function(f) {let v;if(this.some(x=>v=f(x)))return v}
const precTable=t=>Object.fromEntries(t.map(x=>(t=x.splice(-2),x.map(x=>[x,t]))).flat());
const INFIX_PREC = precTable([
	['**',30,31],
	['^','|','&',28,29],
	['*','/',26,27],
	['+','-',24,25],
	['=','!=','<','>','<=','>=',22,23],
	['&&','||',18,19],
	// 17 -- lambda application
	['.',15,16],
	[',',13,14],
	[':=',11,12]
]);
const sops = ['**', '+', '-', '*', '/', '=>', '&&', '||', '!=', '>=', '>', '<=', '<', '.', ':=', '=', '(', ')', '{', '}', '[', ']', ',', '!', '#', '&', '^', '|', '~'];
const lambda = `\u03BB`;
const equal = (a,b,am={},bm={}) => {
	if (a === b) return true;
	if (a.op !== b.op) return false;
	const extmap = (m, a, b) => ({ ...m, ...Object.fromEntries(a.map((x,i) => [x,b[i]])) });
	switch (a.op) {
		case 'var': if (am[a.value] || bm[b.value]) return am[a.value] === b.value;
		case 'number': return a.value === b.value;
		case lambda: return a.lhs.length === b.lhs.length
			&& equal(a.rhs, b.rhs, extmap(am, a.lhs, b.lhs), extmap(bm, b.lhs, a.lhs))
	}
	return equal(a.lhs, b.lhs, am, bm) && equal(a.rhs, b.rhs, am, bm);
};
const PREFIX_PREC = { '!': true, '~': true };
const mw = value => ({ op: 'number', value });
const mu = x => x.value;
const m = f => (...a) => mw(Math[f](...a.map(mu)));
let view;
const intrinsics = { radians: a => mw(mu(a)*Math.PI/180), degrees: a => mw(mu(a)/Math.PI*180),
	hex: a => (view = 16, a), bin: a => (view = 2, a), dec: a => (view = 0, a), oct: a => (view = 8, a),
};
['min','max','abs','sin','cos','tan','log','ceil','floor','random','trunc','exp','sqrt','pow'].forEach(x => intrinsics[x] = m(x));
const builtinvars = {
	pi: mw(Math.PI),
	e: mw(Math.E),
	pair: parse(`${lambda} f s p. p f s`),
	true: parse(`${lambda} a b. a`),
	false: parse(`${lambda} a b. b`)
};
const vars = {}, history = [];
const list = ['#help','#clear','#clearhistory','#export','#import','#vars','#builtin','#intrinsics','#rmfunc','#rmvar']
	.concat(Object.keys(builtinvars))

let query = '', clear = true, res, next = new Promise(r => res = r), suggest;

const mv = (_x,_y,x=(_x<0?stdout.columns+_x:_x+1)+'',y=(_y<0?stdout.rows+_y:_y??'')+'') => y ? `\x1b[${y};${x}H` : `\x1b[${x}G`;
const color = (c = 0xffffff) => {
	const index = x => (x & 0xff) / 43 | 0;
	return `\x1b[38;5;${index(c >> 16) * 36 + index(c >> 8) * 6 + index(c) + 16}m`;
};
const resit = m => mv(0,-extrarows)+m;
const print = m => console.error(m,'\n'.repeat(extrarows));
if (!extrarows)
	process.exit(interp(query =
		process.argv.slice(2).join(' ')+' '+(stdin.isTTY ? '' : await stdin.toArray().then(x => x.toString()))));

console.clear(); w(resit(''));
const emu = x => (w((query = x, `${resit('')}> ${x}\n`)),interp(x));
try { fs.readFileSync('.calc', 'utf-8').split('\n').filter(x => x).forEach(emu); } catch (e) {}
const closeHandler = () => { fs.writeFileSync('.calc', history.join('\n')); process.exit(); };
process.on('SIGTERM', closeHandler); process.on('exit', closeHandler);


function* Tokeniser(src) {
	let index = 0, line = 1, lstart = 0;
  const char = () => src[index] || '';
	const token = (type, value, i = index) => ({ type, value, index: i + 1, line, lstart });
	const getChars = r => { let out = ''; while (char().match(r)) { out += char(); ++index; } return out; };
	while (index < src.length) {
  	while (char().match(/\s/)) { ++index; if (src[index-1] === '\n') { lstart = index; ++line; } }
		const ret = [
			[[['0x', /[0-9a-fA-F]/],['0b',/[01]/],['0',/[0-7]/]], ([s,r]) => {
				if (!src.startsWith(s, index) || !r.test(src[index + s.length])) return;
				index += s.length;
				const f = x => Number.parseInt(x, {'0x':16,'0b':2,'0':8}[s]);
				return token('number', f(getChars(r)));
			}],
			[[,],() => {
				const oind = index;
			}],
			[[[]], () => {
				if (!char().match(/[.0-9]/)) return;
				const i = index;
				let frac = false;
				while (true) {
					if (char() === '.') {
						if (frac) break; frac = true;
					}
					else if (!char().match(/[0-9]/)) break;
					++index;
				}
				const n = Number.parseFloat(src.substring(i, index))
				if (isNaN(n)) {
					index = i;
					return;
				}
				return token('number', n);
			}],
			[[['var', /[a-zA-Z_]/, /[0-9a-zA-Z_]/],
			['string', '"', /[^"]/, true], ['string', '\'', /[^']/, true]], ([t, sr, r, o, f = x => x]) => {
				if (!char().match(sr)) return; if (o) ++index; const out = token(t, f(getChars(r))); if (o) ++index;
				return out;
			}],[sops.concat(lambda),s => src.startsWith(s, index) && (token(s, void 0, (index += s.length) - s.length))]
  	].find_and_map(([t,f]) => t.find_and_map(f));
  	if (ret) { yield ret; continue } if (index >= src.length) break;
	  throw `Tokeniser error (ln ${line}:${index-lstart+1})`;
	} while(1) yield token('EOF');
} function alltokens(q) {const t=[],k=Tokeniser(q);do t.push(k.next().value);while(t[t.length-1].type!=='EOF')return t}

function parse(q) {
	let index = 0; const tokens = alltokens(q), currentToken = () => tokens[index]; return parseExpr();
function parseExpr(mprec = 0) { const eof = () => index >= tokens.length || currentToken().type === 'EOF',
	type = t => !eof() && (t === undefined ? currentToken().type : currentToken().type === t),
	atom = () => { switch (type()) { case 'string': case 'number': case 'var': return (x => ({ op: x.type, ...x }))(tokens[index++]); default: throw 'invalid expression'; } };
	const preExpr = () => { if (type('(')) { ++index; const expr = parseExpr(); ++index; return expr; }
		if (type(lambda)) { ++index;
			const lhs = []; while (type('var')) { lhs.push(currentToken().value); ++index; }
			if (!type('.')) throw `Malformed lambda`; ++index;
			return {lhs,op:lambda,rhs:parseExpr()};
		}
		return atom(); };
	let lhs = preExpr(mprec); while (1) {
		if (!INFIX_PREC[type()]) {
			if (eof() || type(')') || 17 <= mprec) break;
			const rhs = parseExpr(17);
			lhs = {lhs,op:'app',rhs};
			continue;
		}
		const [l,r] = INFIX_PREC[type()]; if (l < mprec) break;
		const op = type(); ++index; const rhs = parseExpr(r); lhs = {lhs,op,rhs}; }
	return lhs;
} }

function str(x, is, isc, i) {
	if (!x) return '';
	const wrap = s => i && i !== x.op ? `(${s})` : s;
	switch (x.op) {
		case 'intrinsic':
		case 'var': case 'number': return x.value;
		case 'app': return wrap(`${str(x.lhs, isc && is, isc, 'app')} ${str(x.rhs, isc && is, isc, true)}`);
		case lambda:
			for (const v in builtinvars) if (isc !== '' && is !== v && equal(x, builtinvars[v])) return v;
			for (const v in vars) if (isc !== '' && is !== v && equal(x, vars[v].value)) return v;
			return wrap(`${lambda}${x.lhs.join(' ')}. ${str(x.rhs, isc && is, isc)}`);
		default: return wrap(`${str(x.lhs, isc && is, isc, true)} ${x.op} ${str(x.rhs, isc && is, isc, true)}`);
	}
}
function run(expr) {
	view = 0;
	//print(JSON.stringify(expr));
	//print(str(expr, void 0, ''));
	const { lhs, rhs, value } = expr,
	l = () => run(lhs), r = () => run(rhs);
	if (![':=','.',','].includes(expr.op) && sops.includes(expr.op)) {
		const lhs = l(), rhs = r();
		if (lhs.op !== 'number' || rhs.op !== 'number') return {lhs,op:expr.op,rhs};
		const ln = mu(lhs), rn = mu(rhs);
		const tru = builtinvars.true, fls = builtinvars.false;
		const b = x => x ? tru : fls;
		switch (expr.op) {
			case '+': return mw(ln + rn); case '-': return mw(ln - rn); case '*': return mw(ln * rn); case '/': return mw(ln / rn);
			case '=': return b(ln === rn); case '!=': return b(ln !== rn);
			case '>=': return b(ln >= rn); case '<=': return b(ln <= rn); case '>': return b(ln > rn); case '<': return b(ln < rn);
			case '!': return b(!rn); case '~': return mw(~rn); case '&': return mw(ln & rn); case '|': return mw(ln | rn);
			case '=>': return ln ? mw(rn) : tru; case '&&': return b(ln && rn); case '||': return b(ln || rn); case '**': return mw(ln ** rn);
		}
	}

	const pair = { op: 'var', value: 'pair' };
	const terms = (e, intro) => { const t = new Set();
		const it = e => { switch (e.op) {
		case 'var': intro || t.add(e.value); break; case 'number': break;
		case lambda: e.lhs.forEach(x => t.add(x)); it(e.rhs); break;
		default: it(e.lhs); it(e.rhs); break; } };
		it(e); return Array.from(t.values()); };
	const _nt = (t, i = 0) => { t = [...t];
		const s = _ => String.fromCharCode((_%26) + 'a'.charCodeAt() + (_/26|0));
		return () => { let x; while (t.includes(x = s(i))) ++i; t.push(x); return x; };
	};

	switch (expr.op) {
		case ',': return run({ lhs: { lhs: pair, op: 'app', rhs:l() }, op: 'app', rhs:r()});
		case lambda: if (expr.rhs.op === lambda) {
			//const rhs = r();
			//return { op: lambda, lhs: lhs.concat(rhs.lhs), rhs: rhs.rhs };
		}
		case 'number': return expr;
		case 'var': return vars[value]?.value ?? builtinvars[value] ?? (() => {
			if (intrinsics[value]) return { op: 'intrinsic', value };
			return expr})();
		case ':=': {
			let l = lhs;
			while (l.op === 'app') l = l.lhs;
			l = l.value;
			list.push(l);
			const r = run(rhs);
			return (vars[l] = { rec: terms(r).includes(l), value: r, query }).value;
		}
		case 'app': {
			const _l = l();
			if (_l.op === 'intrinsic') {
				const args = [];
				const it = e => {
					const l = run({ op: 'app', rhs: builtinvars.true, lhs: e });
					const r = run({ op: 'app', rhs: builtinvars.false, lhs: e });
					args.push(r);
					if (r.op !== 'number') throw 'Bad intrinsic call';
					if (l.op === lambda) it(l);
					else if (l.op !== 'number') throw 'Bad intrinsic call';
					else args.push(l);
				};
				it (r());
				return intrinsics[_l.value](...args);
			}
			if (_l.op === lambda) {
				const v = r();
				let out = _l;
				const lterms = terms(_l, true);
				const riterms = terms(v, true);
				const rterms = terms(v).filter(x => !riterms.includes(x));
				const nt = _nt(lterms.concat(rterms));
				for (const t of rterms) {
					if (lterms.includes(t)) {
						const v = {op: 'var',value: nt()};
						const it = e => {
							switch (e.op) {
								case 'number': return e;
								case 'var': return e.value === t ? v : e;
								case lambda: return {lhs:e.lhs.map(x => x === t ? v.value : x),op:lambda,rhs:it(e.rhs)};
								default: return { lhs: it(e.lhs), op: e.op, rhs: it(e.rhs) };
							}
						};
						out = it(out);
					}
				}
				const l = out;
				const t = l.lhs[0];
				let expv;
				const _v = () => expv ?? (expv = run(v));
				const it = e => {
					switch (e.op) {
						case 'number': return e;
						case 'var': return e.value === t ? _v() : e;
						case lambda: return e.lhs.includes(t) ? e : {...e,rhs:it(e.rhs)};
						default: return { lhs: it(e.lhs), op: e.op, rhs: it(e.rhs) };
					}
				};
				out = it(out.rhs);
				print(str(out));
				if (l.lhs.length > 1) return { rec: _l.rec, lhs: l.lhs.slice(1), op: lambda, rhs: out };
				return run(out);
			}
			return { lhs: _l, op: 'app', rhs: rhs };
		}
	}
}

stdin.setRawMode(true);
stdin.resume();
let oquery = '', oxi, xi = 0, yi = 0, ti = -1;
const prompt = (e = '') => w(resit(`\x1b[J> ${query}\n${(() => {
	if (ti === -1) return '';
	let out = '';
	for (let i = 0; i < suggest.length; ++i) {
		if (i === ti) out += `\x1b[7m`;
		out += ` ${suggest[i]} `;
		if (i === ti) out += `\x1b[27m`;
	}
	return out;
})()}${e}${mv(xi+2,-extrarows)}`));
stdin.on('data', data => {
	let key = data.toString('utf-8');
	if (data[0] === 0x1b) {
		const d = Array.from(data).slice(1).map(x => x.toString(16)).join('');
		key = {
			'5b41': 'uparrow', '5b42': 'downarrow', '5b43': 'rightarrow', '5b44': 'leftarrow', '': 'escape'
		}[d];
		if (key === undefined) console.error(data, d);
	}
	const xc = d => xi = (ti = -1, Math.min(query.length, Math.max(0, xi + d)));
	const yc = d => {
		if (!yi && d > 0) oquery = query;
		yi = Math.min(history.length, Math.max(0, yi + d));
		if (!yi) query = oquery;
		else query = history[history.length - yi];
		xi = query.length;
		ti = -1;
	};
	const tc = () => (++ti, ti %= suggest.length);
	const r = x => (x+'').split('').reverse().join('');
	const word = () => r(r(query.slice(0, xi)).match(/[0-9a-zA-Z_#]*/));
	const repl = (a,b) => query = r(r(query).replace(r(a), r(b)));
	const replword = (a,b) => { repl(a,b); ti = -1; xi = query.length; };
	if (key === '\\') key = lambda;
	switch (key) {
		case 'escape': ti = -1; break;
		case 'uparrow': yc(1); break; case 'downarrow': yc(-1); break;
		case 'leftarrow': xc(-1); break; case 'rightarrow': xc(1); break;
		case '\x03': process.exit();
		case '\t': {
			const s = word();
			if (ti == -1) {
				let ll = extrarows * stdout.columns;
				suggest = list.filter(x => x.startsWith(s)).filter(x => ll > 0 ? (ll -= x.length + 2, true) : 0);
				if (suggest.length === 1) { replword(s, suggest[0]); break; }
				else if (suggest.length === 0) break;
			}
			tc();
			query = repl(s, suggest[ti]);
			xi += suggest[ti].length - s.length;
			break;
		}
		case '\x7f': query = query.slice(0,xc(-1)) + query.slice(xi+1); ti = -1; break;
		case '\n': case '\r': oxi = xi; xi = yi = 0; ti = -1; prompt(); w('\n'); res(); return;
		default: query = query.substr(0, xi) + key + query.substr(xi++); w(key); ti = -1; break;
	}
	prompt();
});

function formatpairs(pairs) {
	const maxlen = Math.max(...pairs.map(x => x[0].length));
	return pairs.map(([k,v]) => `${k}${mv(maxlen)} : ${str(v, void 0, '')}`).join('\n');
}

if (!history.length) print('Type #help for more information');

function interp() {
	query = query.trim();
	if (!query) return;
	let addhist = true;
	const params = (s) => {
		const t = alltokens(query.slice(s.length));
		if (t.length === 1) print(`${s} requires a parameter`);
		return t.slice(0, -1);
	};
	const c = s => query.startsWith(s);
	if (query === '#') process.exit();
	try { switch (true) {
		case c('#help'): print(`
#help						Bring up this info
#clear					Clear the screen
#clearhistory		Clear the history
#export "file"	Export variables
#import "file"	Import variables
#builtin				List builtin variables
#vars						List variables
#intrinsics			List intrinsic functions
#rmvar					Remove variable
`);
			break;
		case c('#rmvar'): { const f = params('#rmvar')[0].value; if (vars[f]) delete vars[f]; print(f); break }
		case c('#builtin'): print(formatpairs(Object.entries(builtinvars))); break;
		case c('#vars'): print(formatpairs(Object.entries(vars).map(([k,v]) => [k, v.value]))); break;
		case c('#intrinsics'): print(formatpairs(Object.keys(intrinsics).map(k => [k,'']))); break;
		case c('#clearhistory'): emu('#export ""'); history.length = 0; emu('#import ""'); emu('#clear'); addhist = false; break;
		case c('#clear'): console.clear(); break;
		case c('#export'): {
			const qs = Object.entries(vars).map(([k,v]) => `${k} := ${str(v.value, void 0, '')}`);
			fs.writeFileSync(`${params('#export')[0].value}.calc`, qs.join('\n'));
			w('\n');
			addhist = false;
			break;
		}
		case c('#import'): {
			const hist = fs.readFileSync(`${params('#import')[0].value}.calc`, 'utf-8').split('\n').filter(x => !history.includes(x));
			hist.forEach(emu);
			addhist = false;
			break;
		}
		case c('#eval'): print(eval(query.slice('#eval'.length))); break;
		default: 
			try {
				const v = run(parse(query));
				const c = 0xffff00;
				const vf = {16:'x',8:'',2:'b'};
				const s = vf[view] ? `0${vf[view]}${v.toString(view)}` : str(v);
				print(`${color(c)}${s}${color()}`);
			} catch (e) { ti = -1; xi = oxi; prompt(e); clear = addhist = false; }
	}
	if (addhist) history.push(query);
	} catch (e) {}
}

while(1) { if (clear) { query = ''; prompt(); } clear = true; await next; next = new Promise(r => res = r); interp(); }
